Структуры данных – это, по сути, и есть структуры, которые могут хранить некоторые данные вместе. Другими словами, они используются для хранения связанных данных. 

В Python существуют четыре встроенных структуры данных: список, кортеж, словарь и множество. Посмотрим, как ими пользоваться, и как они могут облегчить нам жизнь.

### Список
Список1 – это структура данных, которая содержит упорядоченный набор элементов, т.е. хранит последовательность элементов. Это легко представить, если вспомнить список покупок, в котором перечисляется, что нужно купить, с тем лишь исключением, что в списке покупок каждый элемент обычно размещается на отдельной строке, тогда как в Python они разделяются запятыми.

Список элементов должен быть заключён в квадратные скобки, чтобы Python понял, что это список. Как только список создан, можно добавлять, удалять или искать элементы в нём. Поскольку элементы можно добавлять и удалять, мы говорим, что список – это изменяемый тип данных, т.е. его можно модифицировать.

### Краткое введение в объекты и классы

Хотя я и старался до сих пор оттянуть обсуждение объектов и классов, на данном этапе всё же необходимо некоторое пояснение, чтобы вы лучше поняли идею списков. Мы изучим эту тему детально в её собственной главе.

Список – это один из примеров использования объектов и классов. Когда мы назначаем некоторой переменной i значение, скажем, целое число 5, это можно представить себе как создание объекта (т.е. экземпляра) i класса (т.е. типа) int. Чтобы лучше понять это, прочитайте help(int).

Класс может также иметь методы, т.е. функции, определённые для использования только применительно к данному классу. Этот функционал будет доступен только когда имеется объект данного класса. Например, Python предоставляет метод append для класса list, который позволяет добавлять элемент к концу списка. Так mylist.append('and item') добавит эту строку к списку mylist. Обратите внимание на обозначение точкой для доступа к методам объектов

Класс также может иметь поля, которые представляют собой не что иное, как переменные, определённые для использования только применительно к данному классу. Эти переменные/имена можно использовать только тогда, когда имеется объект этого класса. Доступ к полям также осуществляется при помощи точки. Например, mylist.field.

Пример: (сохраните как using_list.py)
```python
# Это мой список покупок 
shoplist = ['яблоки', 'манго', 'морковь', 'бананы'] 

print('Я должен сделать', len(shoplist), 'покупки.') 

print('Покупки:', end=' ') 
for item in shoplist: 
	print(item, end=' ') 
	
print('\nТакже нужно купить риса.') 
shoplist.append('рис') 
print('Теперь мой список покупок таков:', shoplist) 

print('Отсортирую-ка я свой список') 
shoplist.sort() 
print('Отсортированный список покупок выглядит так:', shoplist) 

print('Первое, что мне нужно купить, это', shoplist[0]) 
olditem = shoplist[0] 
del shoplist[0] 
print('Я купил', olditem) 
print('Теперь мой список покупок:', shoplist)
```

Переменная shoplist – это список покупок человека, идущего на рынок. В shoplist мы храним только строки с названиями того, что нужно купить, однако в список можно добавлять любые объекты, включая числа или даже другие списки.

Вывод:
```python
$ python3 using_list.py
Я должен сделать 4 покупки.

Покупки: яблоки манго морковь бананы
Также нужно купить риса.
Теперь мой список покупок таков: ['яблоки', 'манго', 'морковь', 'бананы', 'рис']
Отсортирую-ка я свой список
Отсортированный список покупок выглядит так: ['бананы', 'манго', 'морковь', 'рис', 'яблоки']
Первое, что мне нужно купить, это бананы
Я купил бананы
Теперь мой список покупок: ['манго', 'морковь', 'рис', 'яблоки']
```

### Кортеж

Кортежи служат для хранения нескольких объектов вместе. Их можно рассматривать как аналог списков, но без такой обширной функциональности, которую предоставляет класс списка. Одна из важнейших особенностей кортежей заключается в том, что они неизменяемы, так же, как и строки. Т.е. модифицировать кортежи невозможно.

Кортежи обозначаются указанием элементов, разделённых запятыми; по желанию их можно ещё заключить в круглые скобки.

Кортежи обычно используются в тех случаях, когда оператор или пользовательская функция должны наверняка знать, что набор значений, т.е. кортеж значений, не изменится

Пример: (сохраните как using_tuple.py)
```python
zoo = ('питон', 'слон', 'пингвин') # помните, что скобки не обязательны
print('Количество животных в зоопарке -', len(zoo))

new_zoo = 'обезьяна', 'верблюд', zoo
print('Количество клеток в зоопарке -', len(new_zoo)) 
print('Все животные в новом зоопарке:', new_zoo) 
print('Животные, привезённые из старого зоопарка:', new_zoo[2])
print('Последнее животное, привезённое из старого зоопарка -', new_zoo[2][2]) print('Количество животных в новом зоопарке -', len(new_zoo)-1 + \ 
																								len(new_zoo[2]))
```

Вывод:
```python
$ python3 using_tuple.py
Количество животных в зоопарке - 3
Количество клеток в зоопарке - 3
Все животные в новом зоопарке: ('обезьяна', 'верблюд', ('питон', 'слон', 'пингвин'))
Животные, привезённые из старого зоопарка: ('питон', 'слон', 'пингвин')
Последнее животное, привезённое из старого зоопарка - пингвин
Количество животных в новом зоопарке - 5
```

Скобки
Хотя скобки и не являются обязательными, я предпочитаю всегда указывать их, чтобы было очевидно, что это кортеж, особенно в двусмысленных случаях. Например, print(1, 2,3) и print( (1,2,3) ) делают разные вещи: первое выражение выводит три числа, тогда как второе – кортеж, содержащий эти три числа.

Кортеж, содержащий 0 или 1 элемент
Пустой кортеж создаётся при помощи пустой пары скобок – «myempty = ()». Однако, с кортежем из одного элемента не всё так просто. Его нужно указывать при помощи запятой после первого (и единственного) элемента, чтобы Python мог отличить кортеж от скобок, окружающих объект в выражении. Таким образом, чтобы получить кортеж, содержащий элемент 2, вам потребуется указать «singleton = (2,)».

### Словарь

Словарь – это некий аналог адресной книги, в которой можно найти адрес или контактную информацию о человеке, зная лишь его имя; т.е. некоторые ключи (имена) связаны со значениями (информацией). Заметьте, что ключ должен быть уникальным – вы ведь не сможете получить корректную информацию, если у вас записаны два человека с полностью одинаковыми именами

Обратите также внимание на то, что в словарях в качестве ключей могут использоваться только неизменяемые объекты (как строки), а в качестве значений можно использовать как неизменяемые, так и изменяемые объекты. Точнее говоря, в качестве ключей должны использоваться только простые объекты.

Пары ключ-значение указываются в словаре следующим образом: «d = {key1 : value1, key2 : value2 }». Обратите внимание, что ключ и значение разделяются двоеточием, а пары друг от друга отделяются запятыми, а затем всё это заключается в фигурные скобки.

Помните, что пары ключ-значение никоим образом не упорядочены в словаре. Если вам необходим некоторый порядок, вам придётся отдельно отсортировать словарь перед обращением к нему.
Словари являются экземплярами/объектами класса dict.

Пример: (сохраните как using_dict.py)
```python
# 'ab' - сокращение от 'a'ddress'b'ook

ab = { 'Swaroop' : 'swaroop@swaroopch.com',
		Larry' : 'larry@wall.org',
	  'Matsumoto' : 'matz@ruby-lang.org',
	  'Spammer' : 'spammer@hotmail.com'
	 }

print("Адрес Swaroop'а:", ab['Swaroop'])

# Удаление пары ключ-значение
del ab['Spammer']

print('\nВ адресной книге {0} контакта\n'.format(len(ab)))

for name, address in ab.items():
	print('Контакт {0} с адресом {1}'.format(name, address))

# Добавление пары ключ-значение
ab['Guido'] = 'guido@python.org'

if 'Guido' in ab:
	print("\nАдрес Guido:", ab['Guido'])
```

Вывод:
```python
$ python3 using_dict.py
Адрес Swaroop'а: swaroop@swaroopch.com

В адресной книге 3 контакта

Контакт Swaroop с адресом swaroop@swaroopch.com
Контакт Matsumoto с адресом matz@ruby-lang.org
Контакт Larry с адресом larry@wall.org
Адрес Guido: guido@python.org
```

Ключевые Аргументы и Словари
К слову, если вы использовали ключевые аргументы в ваших функциях, вы уже использовали словари! Только подумайте: вы указали пару ключ-значение среди параметров функции при её определении, а когда обращаетесь к переменным внутри функции, то это, фактически, обращение по ключу к словарю (который в терминах разработчиков компиляторов называется таблицей имён).

### Последовательности

Списки, кортежи и строки являются примерами последовательностей. Но что такое последовательности и что в них такого особенного?

Основные возможности – это проверка принадлежности (т.е. выражения «in» и «not in») и оператор индексирования, позволяющий получить напрямую некоторый элемент последовательности.

Все три типа последовательностей, упоминавшиеся выше (списки, кортежи и строки), также предоставляют операцию получения вырезки, которая позволяет получить вырезку последовательности, т.е. её фрагмент.

Пример: (сохраните как seq.py)
```python
shoplist = ['яблоки', 'манго', 'морковь', 'бананы']
name = 'swaroop'

# Операция индексирования 
print('Элемент 0 -', shoplist[0]) 
print('Элемент 1 -', shoplist[1]) 
print('Элемент 2 -', shoplist[2]) 
print('Элемент 3 -', shoplist[3]) 
print('Элемент -1 -', shoplist[-1]) 
print('Элемент -2 -', shoplist[-2]) 
print('Символ 0 -', name[0])

# Вырезка из списка 
print('Элементы с 1 по 3:', shoplist[1:3]) 
print('Элементы с 2 до конца:', shoplist[2:]) 
print('Элементы с 1 по -1:', shoplist[1:-1]) 
print('Элементы от начала до конца:', shoplist[:])

# Вырезка из строки 
print('Символы с 1 по 3:', name[1:3]) 
print('Символы с 2 до конца:', name[2:]) 
print('Символы с 1 до -1:', name[1:-1]) 
print('Символы от начала до конца:', name[:])
```

Вывод:
```python
$ python3 seq.py 
Элемент 0 - яблоки 
Элемент 1 - манго 
Элемент 2 - морковь 
Элемент 3 - бананы 
Элемент -1 - бананы
Элемент -2 - морковь
Символ 0 - s 
Элементы с 1 по 3: ['манго', 'морковь'] 
Элементы с 2 до конца: ['морковь', 'бананы']
Элементы с 1 по -1: ['манго', 'морковь'] 
Элементы от начала до конца: ['яблоки', 'манго', 'морковь', 'бананы'] 
Символы с 1 по 3: wa 
Символы с 2 до конца: aroop 
Символы с 1 до -1: waroo
Символы от начала до конца: swaroop
```

### Множество

Множества – это неупорядоченные наборы простых объектов. Они необходимы тогда, когда присутствие объекта в наборе важнее порядка или того, сколько раз данный объект там встречается. 
Используя множества, можно осуществлять проверку принадлежности, определять, является ли данное множество подмножеством другого множества, находить пересечения множеств и так далее.
```python
>>> bri = set(['Бразилия', 'Россия', 'Индия'])
>>> 'Индия' in bri
True
>>> 'США' in bri
False
>>> bric = bri.copy()
>>> bric.add('Китай')
>>> bric.issuperset(bri)
True
>>> bri.remove('Россия') 
>>> bri & bric # OR bri.intersection(bric)
{'Бразилия', 'Индия'}
```

### Ссылки

Когда мы создаём объект и присваиваем его переменной, переменная только ссылается на объект, а не представляет собой этот объект! То есть имя переменной указывает на ту часть памяти компьютера, где хранится объект. Это называется привязкой имени к объекту.

Обычно вам не следует об этом беспокоиться, однако есть некоторый неочевидный эффект, о котором нужно помнить:

Пример: (сохраните как reference.py)
```python
print('Простое присваивание') 
shoplist = ['яблоки', 'манго', 'морковь', 'бананы']
mylist = shoplist # mylist - лишь ещё одно имя, указывающее на тот же объект!

del shoplist[0] # Я сделал первую покупку, поэтому удаляю её из списка

print('shoplist:', shoplist) 
print('mylist:', mylist) 
# Обратите внимание, что и shoplist, и mylist выводят один и тот же список 
# без пункта "яблоко", подтверждая тем самым, что они указывают на один 
# объект.

print('Копирование при помощи полной вырезки') 
mylist = shoplist[:] # создаём копию путём полной вырезки 
del mylist[0] # удаляем первый элемент

print('shoplist:', shoplist) 
print('mylist:', mylist) 
# Обратите внимание, что теперь списки разные
```

Вывод:
```python
$ python3 reference.py 
Простое присваивание 
shoplist: ['манго', 'морковь', 'бананы'] 
mylist: ['манго', 'морковь', 'бананы'] 
Копирование при помощи полной вырезки 
shoplist: ['манго', 'морковь', 'бананы'] 
mylist: ['морковь', 'бананы']
```

### Ещё о строках

Мы уже детально обсуждали строки ранее. Что же ещё можно о них узнать? Что ж, вы знали, например, что строки также являются объектами и имеют методы, при помощи которых можно делать практически всё: от проверки части строки до удаления краевых пробелов?

Все строки, используемые вами в программах, являются объектами класса str. Некоторые полезные методы этого класса продемонстрированы на примере ниже. Чтобы посмотреть весь список методов, выполните help(str).

Пример: (сохраните как str_methods.py)
```python
name = 'Swaroop' # Это объект строки

if name.startswith('Swa'):
	print('Да, строка начинается на "Swa"')

if 'a' in name:
	print('Да, она содержит строку "a"')

if name.find('war') != -1:
	print('Да, она содержит строку "war"')

delimiter = '_*_'
mylist = ['Бразилия', 'Россия', 'Индия', 'Китай'] 
print(delimiter.join(mylist))
```

Вывод:
```python
$ python3 str_methods.py 
Да, строка начинается на "Swa" 
Да, она содержит строку "a" 
Да, она содержит строку "war" 
Бразилия_*_Россия_*_Индия_*_Китай
```

Метод find используется для определения позиции данной подстроки в строке; find возвращает -1, если подстрока не обнаружена.
